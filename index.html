<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>æ˜Ÿé™…è¿½å‡»è€…</title>
    <!-- ç°ä»£åŒ–å­—ä½“ -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500&display=swap" rel="stylesheet">
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            background: #000;
            border: none;
        }

        /* å¢å¼ºçŠ¶æ€æ  */
        #status {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            background: linear-gradient(45deg, #00c6ff, #0072ff);
            color: white;
            border-radius: 8px;
            font-size: 18px;
            box-shadow: 0 0 10px rgba(0, 114, 255, 0.5);
            animation: pulse 2s infinite;
            border: 1px solid rgba(255, 255, 255, 0.3);
            z-index: 100;
        }

        @keyframes pulse {
            0% {
                transform: translateX(-50%) scale(1);
            }

            50% {
                transform: translateX(-50%) scale(1.02);
            }

            100% {
                transform: translateX(-50%) scale(1);
            }
        }

        /* æ§åˆ¶é¢æ¿ */
        #controlPanel {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 10px;
            font-family: 'Orbitron', sans-serif;
            color: white;
            display: flex;
            gap: 15px;
            font-size: 16px;
            box-shadow: 0 0 10px #00ffcc66;
            z-index: 100;
        }
    </style>
</head>

<body>
    <div id="status">æ­£åœ¨è¿æ¥æœåŠ¡å™¨...</div>
    <canvas id="gameCanvas"></canvas>
    <!-- æ§åˆ¶é¢æ¿ -->
    <div id="controlPanel">
        <div>ğŸ® æ§åˆ¶ï¼šW/A/S/D ç§»åŠ¨ï¼Œç©ºæ ¼å°„å‡»</div>
    </div>

    <script src="https://cdn.socket.io/4.3.2/socket.io.min.js"></script>
    <script>
        // ==================== æ¸¸æˆé…ç½® ====================
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");

        // åŠ¨æ€è®¾ç½®canvaså°ºå¯¸
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        const PLAYER_SIZE = 30;   // ç©å®¶æ–¹å—å¤§å°
        const BULLET_RADIUS = 7;  // å­å¼¹åœ†çƒåŠå¾„
        const MONSTER_SIZE = 35;  // æ€ªç‰©æ–¹å—å¤§å°
        let playerId = null;
        let players = {};         // æ‰€æœ‰ç©å®¶ { id: { x, y, color } }
        let bullets = [];         // æ‰€æœ‰å­å¼¹ { id, x, y, ownerId }
        let monsters = [];        // æ‰€æœ‰æ€ªç‰© { id, x, y }
        let explosions = [];      // çˆ†ç‚¸ç‰¹æ•ˆæ•°ç»„

        // å•æœºæ¨¡å¼æ ‡å¿—å’Œæœ¬åœ°æ•°æ®
        let isOnline = false;
        let offlinePlayer = {
            id: "local",
            x: 400,
            y: 500,
            color: "#00ff00"
        };
        let offlineBullets = [];
        let offlineMonsters = [];

        // ==================== WebSocket è¿æ¥ ====================
        const socket = io("http://localhost:3000"); // æ›¿æ¢ä¸ºä½ çš„æœåŠ¡å™¨åœ°å€
        const statusDiv = document.getElementById("status");

        // è¿æ¥çŠ¶æ€æ£€æµ‹ï¼ˆ3ç§’è¶…æ—¶ï¼‰
        const connectTimeout = setTimeout(() => {
            if (!socket.connected) {
                statusDiv.textContent = "æœåŠ¡å™¨æœªè¿æ¥ï¼Œå·²è¿›å…¥å•æœºæ¨¡å¼";
                statusDiv.style.backgroundColor = "#ff4444";
                isOnline = false;
                initOfflineGame();
            }
        }, 3000);

        // è¿æ¥æˆåŠŸå›è°ƒ
        socket.on("connect", () => {
            clearTimeout(connectTimeout);
            isOnline = true;
            statusDiv.textContent = "å·²è¿æ¥æœåŠ¡å™¨";
            statusDiv.style.backgroundColor = "#44ff44";
            // é‡ç½®æœ¬åœ°æ•°æ®
            offlineBullets = [];
            offlineMonsters = [];
        });

        // è¿æ¥æ–­å¼€å›è°ƒ
        socket.on("disconnect", () => {
            isOnline = false;
            statusDiv.textContent = "æœåŠ¡å™¨æ–­å¼€ï¼Œå·²è¿›å…¥å•æœºæ¨¡å¼";
            statusDiv.style.backgroundColor = "#ff4444";
            initOfflineGame();
        });

        document.getElementById("connectionStatus").textContent = "åœ¨çº¿";
        document.getElementById("connectionStatus").style.color = "#44ff44";

        socket.on("connect", () => {
            document.getElementById("connectionStatus").textContent = "åœ¨çº¿";
            document.getElementById("connectionStatus").style.color = "#44ff44";
        });

        socket.on("disconnect", () => {
            document.getElementById("connectionStatus").textContent = "å•æœºæ¨¡å¼";
            document.getElementById("connectionStatus").style.color = "#ff4444";
        });

        // æ¥æ”¶ç©å®¶åˆ—è¡¨
        socket.on("players", (data) => {
            players = data;
        });

        // æ¥æ”¶å­å¼¹åˆ—è¡¨
        socket.on("bullets", (data) => {
            bullets = data;
        });

        // æ¥æ”¶æ€ªç‰©åˆ—è¡¨
        socket.on("monsters", (data) => {
            monsters = data;
        });

        // æ¥æ”¶æ–°ç©å®¶åŠ å…¥
        socket.on("playerJoined", (id) => {
            if (!players[id]) {
                players[id] = {
                    x: Math.random() * (canvas.width - PLAYER_SIZE),
                    y: Math.random() * (canvas.height - PLAYER_SIZE),
                    color: getRandomColor()
                };
            }
        });

        // æ¥æ”¶ç©å®¶ç¦»å¼€
        socket.on("playerLeft", (id) => {
            delete players[id];
        });

        // ==================== è¾“å…¥æ§åˆ¶ ====================
        document.addEventListener("keydown", (e) => {
            if (isOnline) {
                // åœ¨çº¿æ¨¡å¼æ§åˆ¶
                const speed = 5;
                if (e.key === "w") movePlayer(0, -speed);
                if (e.key === "s") movePlayer(0, speed);
                if (e.key === "a") movePlayer(-speed, 0);
                if (e.key === "d") movePlayer(speed, 0);
                if (e.key === " ") shootBullet();
            } else {
                // å•æœºæ¨¡å¼æ§åˆ¶
                handleOfflineInput(e);
            }
        });

        function movePlayer(dx, dy) {
            if (!playerId || !players[playerId]) return;
            const player = players[playerId];
            player.x = Math.max(0, Math.min(canvas.width - PLAYER_SIZE, player.x + dx));
            player.y = Math.max(0, Math.min(canvas.height - PLAYER_SIZE, player.y + dy));
            socket.emit("move", { x: player.x, y: player.y });
        }

        function shootBullet() {
            const player = players[playerId];
            const bullet = {
                x: player.x + PLAYER_SIZE / 2,
                y: player.y,
                ownerId: playerId
            };
            socket.emit("shoot", bullet);
        }

        // å•æœºæ¨¡å¼è¾“å…¥å¤„ç†
        function handleOfflineInput(e) {
            const speed = 7;
            if (e.key.toLowerCase() === "a") {
                offlinePlayer.x = Math.max(0, offlinePlayer.x - speed);
            }
            if (e.key.toLowerCase() === "d") {
                offlinePlayer.x = Math.min(canvas.width - PLAYER_SIZE, offlinePlayer.x + speed);
            }
            if (e.key.toLowerCase() === "w") {
                offlinePlayer.y = Math.max(0, offlinePlayer.y - speed);
            }
            if (e.key.toLowerCase() === "s") {
                offlinePlayer.y = Math.min(canvas.height - PLAYER_SIZE, offlinePlayer.y + speed);
            }
            if (e.key === " ") {
                // å‘å°„å­å¼¹ï¼ˆå•æœºæ¨¡å¼ï¼‰
                offlineBullets.push({
                    x: offlinePlayer.x + PLAYER_SIZE / 2,
                    y: offlinePlayer.y,
                    dy: -7
                });
            }
        }

        // ==================== æ¸²æŸ“å¾ªç¯ ====================
        function drawBackground() {
            // æ˜Ÿç©ºèƒŒæ™¯
            const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
            gradient.addColorStop(0, '#0a002e');
            gradient.addColorStop(1, '#000000');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // æ˜Ÿç‚¹
            for (let i = 0; i < 150; i++) {
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(Math.random() * canvas.width, Math.random() * canvas.height, Math.random() * 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function gameLoop() {
            drawBackground(); // ç»˜åˆ¶æ˜Ÿç©ºèƒŒæ™¯

            // ç»˜åˆ¶çˆ†ç‚¸ç‰¹æ•ˆ
            ctx.save();
            explosions.forEach(explosion => {
                ctx.globalAlpha = explosion.alpha;
                const gradient = ctx.createRadialGradient(
                    explosion.x, explosion.y, 0,
                    explosion.x, explosion.y, explosion.radius
                );
                gradient.addColorStop(0, '#ffff66');
                gradient.addColorStop(1, '#ff003300');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(explosion.x, explosion.y, explosion.radius, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.restore();

            if (isOnline) {
                // ç»˜åˆ¶åœ¨çº¿æ¨¡å¼æ•°æ®
                // ç»˜åˆ¶æ€ªç‰©
                ctx.save();
                ctx.fillStyle = '#ff3366';
                ctx.shadowColor = '#ff0033';
                ctx.shadowBlur = 15;
                monsters.forEach(monster => {
                    ctx.fillRect(monster.x, monster.y, MONSTER_SIZE, MONSTER_SIZE);
                });
                ctx.restore();

                // ç»˜åˆ¶å­å¼¹
                ctx.save();
                ctx.fillStyle = '#ffcc00';
                ctx.shadowColor = '#ffff66';
                ctx.shadowBlur = 8;
                bullets.forEach(bullet => {
                    ctx.beginPath();
                    ctx.arc(bullet.x, bullet.y, BULLET_RADIUS, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.restore();

                // ç»˜åˆ¶ç©å®¶
                for (const id in players) {
                    const p = players[id];
                    ctx.save();
                    const playerGradient = ctx.createLinearGradient(
                        p.x, p.y,
                        p.x + PLAYER_SIZE,
                        p.y + PLAYER_SIZE
                    );
                    playerGradient.addColorStop(0, '#00ffcc');
                    playerGradient.addColorStop(1, '#9933ff');
                    ctx.fillStyle = playerGradient;
                    ctx.shadowColor = '#9933ff';
                    ctx.shadowBlur = 10;
                    ctx.fillRect(p.x, p.y, PLAYER_SIZE, PLAYER_SIZE);
                    ctx.restore();
                }
            } else {
                // ç»˜åˆ¶å•æœºæ¨¡å¼æ•°æ®
                // ç»˜åˆ¶æ€ªç‰©
                ctx.save();
                ctx.fillStyle = '#ff3366';
                ctx.shadowColor = '#ff0033';
                ctx.shadowBlur = 15;
                offlineMonsters.forEach(monster => {
                    ctx.fillRect(monster.x, monster.y, MONSTER_SIZE, MONSTER_SIZE);
                });
                ctx.restore();

                // ç»˜åˆ¶å­å¼¹
                ctx.save();
                ctx.fillStyle = '#ffcc00';
                ctx.shadowColor = '#ffff66';
                ctx.shadowBlur = 8;
                offlineBullets.forEach(bullet => {
                    ctx.beginPath();
                    ctx.arc(bullet.x, bullet.y, BULLET_RADIUS, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.restore();

                // ç»˜åˆ¶ç©å®¶
                ctx.save();
                const playerGradient = ctx.createLinearGradient(
                    offlinePlayer.x, offlinePlayer.y,
                    offlinePlayer.x + PLAYER_SIZE,
                    offlinePlayer.y + PLAYER_SIZE
                );
                playerGradient.addColorStop(0, '#00ffcc');
                playerGradient.addColorStop(1, '#9933ff');
                ctx.fillStyle = playerGradient;
                ctx.shadowColor = '#9933ff';
                ctx.shadowBlur = 10;
                ctx.fillRect(offlinePlayer.x, offlinePlayer.y, PLAYER_SIZE, PLAYER_SIZE);
                ctx.restore();

                updateOfflineGame();
            }
            requestAnimationFrame(gameLoop);
        }
        gameLoop();

        // å•æœºæ¨¡å¼æœ¬åœ°æ•°æ®åˆå§‹åŒ–
        function initOfflineGame() {
            if (Object.keys(players).length === 0 || !players["local"]) {
                // åˆå§‹åŒ–æœ¬åœ°ç©å®¶
                offlinePlayer = {
                    id: "local",
                    x: canvas.width / 2,
                    y: canvas.height - 80,
                    color: "#00ff00"
                };
                players = { [offlinePlayer.id]: offlinePlayer };
            }
            // ç”Ÿæˆåˆå§‹æ€ªç‰©
            if (offlineMonsters.length === 0) {
                for (let i = 0; i < 5; i++) {
                    offlineMonsters.push({
                        x: Math.random() * (canvas.width - MONSTER_SIZE),
                        y: Math.random() * (canvas.height / 2),
                        dx: (Math.random() > 0.5 ? 1 : -1) * 3
                    });
                }
            }
        }

        // å•æœºæ¨¡å¼æ›´æ–°é€»è¾‘
        function updateOfflineGame() {
            // å­å¼¹ç§»åŠ¨
            offlineBullets = offlineBullets.filter(bullet => {
                bullet.y += bullet.dy;
                return bullet.y > 0;
            });

            // æ€ªç‰©ç§»åŠ¨ï¼ˆå·¦å³æ‘†åŠ¨ï¼‰
            offlineMonsters.forEach(monster => {
                monster.x += monster.dx;
                if (monster.x <= 0 || monster.x >= canvas.width - MONSTER_SIZE) {
                    monster.dx *= -1;
                }
            });

            // ç¢°æ’æ£€æµ‹ä¸çˆ†ç‚¸ç‰¹æ•ˆ
            offlineBullets.forEach((bullet, bIndex) => {
                offlineMonsters.forEach((monster, mIndex) => {
                    if (
                        bullet.x > monster.x &&
                        bullet.x < monster.x + MONSTER_SIZE &&
                        bullet.y < monster.y + MONSTER_SIZE &&
                        bullet.y > monster.y
                    ) {
                        // åˆ›å»ºçˆ†ç‚¸æ•ˆæœ
                        explosions.push({
                            x: monster.x + MONSTER_SIZE / 2,
                            y: monster.y + MONSTER_SIZE / 2,
                            radius: 0,
                            maxRadius: 40,
                            alpha: 1
                        });

                        offlineBullets.splice(bIndex, 1);
                        offlineMonsters.splice(mIndex, 1);

                        // ç”Ÿæˆæ–°æ€ªç‰©
                        offlineMonsters.push({
                            x: Math.random() * (canvas.width - MONSTER_SIZE),
                            y: Math.random() * (canvas.height / 2),
                            dx: (Math.random() > 0.5 ? 1 : -1) * 3
                        });
                    }
                });
            });

            // æ›´æ–°çˆ†ç‚¸ç‰¹æ•ˆ
            explosions = explosions.filter(explosion => {
                explosion.radius += 2;
                explosion.alpha -= 0.05;
                return explosion.radius < explosion.maxRadius && explosion.alpha > 0;
            });
        }

        // å·¥å…·å‡½æ•°
        function getRandomColor() {
            const letters = '0123456789ABCDEF';
            let color = '#';
            for (let i = 0; i < 6; i++) color += letters[Math.floor(Math.random() * 16)];
            return color;
        }
    </script>
</body>

</html>